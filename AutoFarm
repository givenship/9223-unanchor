-- AutoFarm v3
-- Go straight to target unless obstacle blocks the way
-- Get as close as possible at all times
-- Monsters: follow Humans, click after idle 5s within 30 studs
-- Humans: follow Monsters, 30cps, circle, waypoint, anti-back, target memory

print("um")

local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")
local LP = Players.LocalPlayer

-- ========== CONFIG ==========
local JUMP_EVERY = 1
local PREDICT = 0.3
local Y_PENALTY = 3
local MAX_Y = 50
local JUMP_H = 8.5
local MAX_OBS = 9
local STUCK_TIME = 2
local STUCK_DIST = 1

-- Monsters
local MONSTER_IDLE_TIME = 5
local MONSTER_CLICK_RANGE = 30

-- Humans
local HUMAN_CPS = 30
local HUMAN_DETECT_RANGE = 30

-- ========== STATE ==========
local running = false
local heartbeat = nil
local lastJump = 0
local lastClickTime = 0

local monsterIdleStart = nil
local monsterLastPos = nil
local memoryTarget = nil
local circlePart = nil

-- pathfinding (only used when blocked)
local currentWaypoints = nil
local currentWpIndex = 2
local currentPath = nil
local pathKey = nil
local lastPathTime = 0
local blockedConn = nil
local usePathfind = false -- flag: are we currently pathfinding around obstacle?

-- stuck
local stuckPos = nil
local stuckStart = nil

-- ========== SETTINGS ==========
local function S()
    return getgenv().AutoFarmSettings or {}
end

-- ========== RAYCAST ==========
local rayP = RaycastParams.new()
rayP.FilterType = Enum.RaycastFilterType.Exclude

local function refreshRay()
    local t = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p.Character then t[#t + 1] = p.Character end
    end
    rayP.FilterDescendantsInstances = t
end

-- ========== HELPERS ==========
local function root(p)
    local c = p.Character
    return c and c:FindFirstChild("HumanoidRootPart")
end

local function hum(p)
    local c = p.Character
    return c and c:FindFirstChildOfClass("Humanoid")
end

local function alive(p)
    local h = hum(p)
    return h and h.Health > 0
end

local function team(p)
    return p.Team and p.Team.Name
end

local function isMonster(p) return team(p) == "Monsters" end
local function isHuman(p) return team(p) == "Humans" end

local function dist(a, b)
    local ra, rb = root(a), root(b)
    if not ra or not rb then return math.huge end
    return (ra.Position - rb.Position).Magnitude
end

local function distToPos(p, pos)
    local r = root(p)
    if not r then return math.huge end
    return (r.Position - pos).Magnitude
end

local function score(p)
    local a, b = root(LP), root(p)
    if not a or not b then return math.huge end
    local d = a.Position - b.Position
    local horiz = math.sqrt(d.X * d.X + d.Z * d.Z)
    local vert = math.abs(d.Y)
    if vert > MAX_Y then return math.huge end
    return horiz + vert * Y_PENALTY
end

local function predict(p)
    local r = root(p)
    if not r then return nil end
    local v = r.AssemblyLinearVelocity
    return r.Position + Vector3.new(v.X, 0, v.Z) * PREDICT
end

local function getVelocity(p)
    local r = root(p)
    if not r then return Vector3.zero end
    return r.AssemblyLinearVelocity
end

local function press()
    pcall(function()
        mouse1press()
        task.defer(function() mouse1release() end)
    end)
end

-- ========== MOVEMENT ==========
local function moveTo(pos)
    local h = hum(LP)
    if h then h:MoveTo(pos) end
end

local function stopMove()
    local h, r = hum(LP), root(LP)
    if h and r then h:MoveTo(r.Position) end
end

local function face(target)
    local a, b = root(LP), root(target)
    if not a or not b then return end
    local d = b.Position - a.Position
    local flat = Vector3.new(d.X, 0, d.Z)
    if flat.Magnitude < 0.1 then return end
    a.CFrame = CFrame.lookAt(a.Position, a.Position + flat.Unit)
end

-- ========== JUMP ==========
local function jump()
    local h = hum(LP)
    if not h then return end
    h.JumpHeight = JUMP_H
    h.UseJumpPower = false
    local state = h:GetState()
    if state == Enum.HumanoidStateType.Running
        or state == Enum.HumanoidStateType.RunningNoPhysics
        or state == Enum.HumanoidStateType.Landed
        or state == Enum.HumanoidStateType.None then
        h:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end

local function tryJump()
    local now = tick()
    if now - lastJump >= JUMP_EVERY then
        jump()
        lastJump = now
    end
end

-- ========== OBSTACLE DETECTION ==========

-- Check if there's an obstacle between us and a target position
local function hasObstacleTo(targetPos)
    local r = root(LP)
    if not r then return false end
    refreshRay()

    local dir = targetPos - r.Position
    local horizDir = Vector3.new(dir.X, 0, dir.Z)
    if horizDir.Magnitude < 2 then return false end -- too close to check

    -- raycast at waist level toward target (max 30 studs)
    local checkDist = math.min(horizDir.Magnitude, 30)
    local hit = workspace:Raycast(r.Position, horizDir.Unit * checkDist, rayP)

    if not hit then return false end -- clear path

    -- hit something: check if it's the ground (normal pointing up = floor, not wall)
    if hit.Normal.Y > 0.8 then return false end -- it's floor/ramp, not a wall

    return true
end

-- Check obstacle height directly in front
local function obsHeight()
    local r = root(LP)
    if not r then return 0 end
    refreshRay()
    local foot = r.Position - Vector3.new(0, 2.5, 0)
    local fwd = r.CFrame.LookVector * 4
    if not workspace:Raycast(foot, fwd, rayP) then return 0 end
    for h = 1, 16 do
        if not workspace:Raycast(foot + Vector3.new(0, h, 0), fwd, rayP) then
            return h
        end
    end
    return 99
end

local function sidestep()
    local r, h = root(LP), hum(LP)
    if not r or not h then return end
    refreshRay()
    local rHit = workspace:Raycast(r.Position, r.CFrame.RightVector * 6, rayP)
    local lHit = workspace:Raycast(r.Position, -r.CFrame.RightVector * 6, rayP)
    if not rHit then
        h:MoveTo(r.Position + r.CFrame.RightVector * 5)
    elseif not lHit then
        h:MoveTo(r.Position - r.CFrame.RightVector * 5)
    else
        jump()
    end
end

local function handleObs()
    local h = obsHeight()
    if h >= 2 and h <= MAX_OBS then
        jump()
    elseif h > MAX_OBS then
        sidestep()
    end
end

-- ========== STUCK DETECTION ==========
local function updateStuck()
    local r = root(LP)
    if not r then return false end
    local pos = r.Position
    local now = tick()
    if stuckPos and (pos - stuckPos).Magnitude < STUCK_DIST then
        if not stuckStart then
            stuckStart = now
        elseif now - stuckStart >= STUCK_TIME then
            stuckStart = now
            return true -- we are stuck
        end
    else
        stuckStart = nil
    end
    stuckPos = pos
    return false
end

-- ========== CIRCLE ==========
local function destroyCircle()
    if circlePart then
        pcall(function() circlePart:Destroy() end)
        circlePart = nil
    end
end

local function updateCircle()
    local s = S()
    if not s.ShowCircle or not running then
        destroyCircle()
        return
    end

    local r = root(LP)
    if not r then destroyCircle() return end

    local radius = s.DetectRadius or HUMAN_DETECT_RANGE

    if not circlePart or not circlePart.Parent then
        circlePart = Instance.new("Part")
        circlePart.Name = "AutoFarmCircle"
        circlePart.Shape = Enum.PartType.Cylinder
        circlePart.Anchored = true
        circlePart.CanCollide = false
        circlePart.Material = Enum.Material.ForceField
        circlePart.Transparency = 0.75
        circlePart.Parent = workspace
    end

    local footY = r.Position.Y - 3
    circlePart.Size = Vector3.new(0.1, radius * 2, radius * 2)
    circlePart.CFrame = CFrame.new(r.Position.X, footY, r.Position.Z) * CFrame.Angles(0, 0, math.rad(90))

    local found = false
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LP and isMonster(p) and alive(p) then
            if dist(LP, p) <= radius then
                found = true
                break
            end
        end
    end
    circlePart.Color = found and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(200, 0, 0)
end

-- ========== PATHFIND (only when blocked) ==========
local function clearPath()
    currentWaypoints = nil
    currentWpIndex = 2
    if blockedConn then
        pcall(function() blockedConn:Disconnect() end)
        blockedConn = nil
    end
    currentPath = nil
    pathKey = nil
    usePathfind = false
end

local function computePath(targetPos)
    local r = root(LP)
    if not r then return false end
    local path = PathfindingService:CreatePath({
        AgentRadius = 2, AgentHeight = 5,
        AgentCanJump = true, AgentCanClimb = false,
        WaypointSpacing = 3
    })
    local ok = pcall(function() path:ComputeAsync(r.Position, targetPos) end)
    if not ok or path.Status ~= Enum.PathStatus.Success then return false end
    if blockedConn then pcall(function() blockedConn:Disconnect() end) end
    currentPath = path
    currentWaypoints = path:GetWaypoints()
    currentWpIndex = 2
    blockedConn = path.Blocked:Connect(function() clearPath() end)
    return true
end

local function advanceWaypoint()
    if not currentWaypoints then return nil end
    while currentWpIndex <= #currentWaypoints do
        local wp = currentWaypoints[currentWpIndex]
        local r = root(LP)
        if not r then return nil end
        local toWp = wp.Position - r.Position
        local behind = (toWp.X * r.CFrame.LookVector.X + toWp.Z * r.CFrame.LookVector.Z) < -1
        if (r.Position - wp.Position).Magnitude < 3 or behind then
            currentWpIndex = currentWpIndex + 1
        else
            return wp
        end
    end
    clearPath()
    return nil
end

-- ========== SMART MOVE ==========
-- Go straight unless obstacle, then pathfind around it

local function smartMove(targetPos, key)
    local r = root(LP)
    if not r then return end

    -- if currently pathfinding, check if path is still needed
    if usePathfind then
        -- re-check: is path to target clear now?
        if not hasObstacleTo(targetPos) then
            clearPath()
            -- go straight
            moveTo(targetPos)
            handleObs()
            return
        end

        -- continue pathfinding
        local now = tick()
        if not currentWaypoints or pathKey ~= key or now - lastPathTime > 1.5 then
            computePath(targetPos)
            pathKey = key
            lastPathTime = now
        end

        local wp = advanceWaypoint()
        if wp then
            if wp.Action == Enum.PathWaypointAction.Jump then jump() end
            handleObs()
            moveTo(wp.Position)
        else
            -- ran out of waypoints, go direct
            moveTo(targetPos)
            handleObs()
        end
        return
    end

    -- not pathfinding: try direct
    local blocked = hasObstacleTo(targetPos)

    if not blocked then
        -- clear path, go straight
        moveTo(targetPos)
        handleObs()
        return
    end

    -- obstacle detected: can we jump it?
    local oh = obsHeight()
    if oh >= 2 and oh <= MAX_OBS then
        jump()
        moveTo(targetPos)
        return
    end

    -- too tall or complex: start pathfinding
    usePathfind = true
    if computePath(targetPos) then
        pathKey = key
        lastPathTime = tick()
    end

    local wp = advanceWaypoint()
    if wp then
        if wp.Action == Enum.PathWaypointAction.Jump then jump() end
        handleObs()
        moveTo(wp.Position)
    else
        -- pathfind failed, try sidestep
        sidestep()
    end
end

-- ========== TARGET FINDING ==========

local function findEnemyInRadius(radius)
    local myTeam = team(LP)
    local best, bestS = nil, math.huge
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LP and alive(p) then
            local t = team(p)
            local ok = (myTeam == "Monsters" and t == "Humans") or (myTeam == "Humans" and t == "Monsters")
            if ok and dist(LP, p) <= radius then
                local s = score(p)
                if s < bestS then best, bestS = p, s end
            end
        end
    end
    return best
end

local function findAnyEnemy()
    local myTeam = team(LP)
    local best, bestS = nil, math.huge
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LP and alive(p) then
            local t = team(p)
            local ok = (myTeam == "Monsters" and t == "Humans") or (myTeam == "Humans" and t == "Monsters")
            if ok then
                local s = score(p)
                if s < bestS then best, bestS = p, s end
            end
        end
    end
    return best
end

local function isMovingAway(target)
    local a, b = root(LP), root(target)
    if not a or not b then return false end
    local toUs = (a.Position - b.Position).Unit
    local vel = getVelocity(target)
    local horizVel = Vector3.new(vel.X, 0, vel.Z)
    if horizVel.Magnitude < 2 then return false end
    return (toUs.X * horizVel.Unit.X + toUs.Z * horizVel.Unit.Z) < -0.3
end

-- ========== MONSTERS FRAME ==========

local function monsterFrame()
    local target = findAnyEnemy()
    if not target then
        stopMove()
        monsterIdleStart = nil
        clearPath()
        return
    end

    local d = dist(LP, target)
    local r = root(LP)

    -- idle detection
    if r then
        local pos = r.Position
        if monsterLastPos and (pos - monsterLastPos).Magnitude < 0.5 then
            if not monsterIdleStart then monsterIdleStart = tick() end
        else
            monsterIdleStart = nil
        end
        monsterLastPos = pos
    end

    -- click if idle 5s within 30 studs
    if monsterIdleStart and (tick() - monsterIdleStart >= MONSTER_IDLE_TIME) and d <= MONSTER_CLICK_RANGE then
        face(target)
        press()
        monsterIdleStart = tick()
    end

    tryJump()

    -- always move toward target (get as close as possible)
    local tpos = predict(target) or (root(target) and root(target).Position)
    if tpos then
        smartMove(tpos, target)
    end

    -- if stuck, try to unstick
    if updateStuck() then
        local oh = obsHeight()
        if oh >= 2 then jump() else sidestep() end
    end
end

-- ========== HUMANS FRAME ==========

local function humanFrame()
    local s = S()
    local detectRadius = s.DetectRadius or HUMAN_DETECT_RANGE
    local now = tick()

    local target = nil

    -- target memory
    if s.TargetMemory and memoryTarget then
        if alive(memoryTarget) and isMonster(memoryTarget) then
            if dist(LP, memoryTarget) <= detectRadius * 3 then
                target = memoryTarget
            else
                memoryTarget = nil
            end
        else
            memoryTarget = nil
        end
    end

    if not target then
        target = findEnemyInRadius(detectRadius)
    end

    -- no target in radius
    if not target then
        local wp = s.Waypoint
        if wp then
            local d = distToPos(LP, wp)
            if d > 3 then
                tryJump()
                smartMove(wp, "waypoint")
                if updateStuck() then
                    local oh = obsHeight()
                    if oh >= 2 then jump() else sidestep() end
                end
            else
                stopMove()
                clearPath()
            end
        else
            target = findAnyEnemy()
            if not target then
                stopMove()
                clearPath()
                return
            end
        end
    end

    if not target then return end

    if s.TargetMemory then
        memoryTarget = target
    end

    local d = dist(LP, target)

    -- anti-back
    if s.AntiBack and isMovingAway(target) then
        local a, b = root(LP), root(target)
        if a and b then
            local flat = Vector3.new(a.Position.X - b.Position.X, 0, a.Position.Z - b.Position.Z)
            if flat.Magnitude > 0.1 then
                moveTo(a.Position + flat.Unit * 5)
            end
        end
        tryJump()
        return
    end

    -- attack: 30cps when close + keep moving closer
    local atkRange = 4
    if d <= atkRange then
        face(target)
        local interval = 1 / HUMAN_CPS
        if now - lastClickTime >= interval then
            press()
            lastClickTime = now
        end
    end

    -- ALWAYS move toward target (get as close as possible, even while attacking)
    tryJump()
    local tpos = predict(target) or (root(target) and root(target).Position)
    if tpos then
        smartMove(tpos, target)
    end

    if updateStuck() then
        local oh = obsHeight()
        if oh >= 2 then jump() else sidestep() end
    end
end

-- ========== MAIN ==========
local function onFrame()
    if not running then return end
    if not alive(LP) then
        monsterIdleStart = nil
        return
    end

    local myTeam = team(LP)
    if myTeam == "Humans" then
        updateCircle()
    else
        destroyCircle()
    end

    if myTeam == "Monsters" then
        monsterFrame()
    elseif myTeam == "Humans" then
        humanFrame()
    end
end

-- ========== CONTROL ==========
local function startFarm()
    if running then return end
    running = true

    local h = hum(LP)
    if h then
        h.JumpHeight = JUMP_H
        h.UseJumpPower = false
    end

    lastJump = tick()
    lastClickTime = tick()
    monsterIdleStart = nil
    monsterLastPos = root(LP) and root(LP).Position
    memoryTarget = nil
    stuckPos = nil
    stuckStart = nil
    clearPath()

    heartbeat = RunService.Heartbeat:Connect(onFrame)
    print("[AutoFarm] ON - " .. tostring(team(LP)))
end

local function stopFarm()
    running = false
    if heartbeat then heartbeat:Disconnect() heartbeat = nil end
    clearPath()
    destroyCircle()
    stopMove()
    monsterIdleStart = nil
    monsterLastPos = nil
    memoryTarget = nil
    stuckPos = nil
    stuckStart = nil
    print("[AutoFarm] OFF")
end

local function setWaypoint()
    local r = root(LP)
    if not r then return end
    local s = S()
    s.Waypoint = r.Position
    getgenv().AutoFarmSettings = s
    print("[AutoFarm] Waypoint set")
end

local function removeWaypoint()
    local s = S()
    s.Waypoint = nil
    getgenv().AutoFarmSettings = s
    print("[AutoFarm] Waypoint removed")
end

getgenv().AutoFarmControl = {
    Start = startFarm,
    Stop = stopFarm,
    SetWaypoint = setWaypoint,
    RemoveWaypoint = removeWaypoint,
    IsRunning = function() return running end
}

if getgenv().AutoFarmSettings and getgenv().AutoFarmSettings.Enabled then
    startFarm()
end

print("[AutoFarm] Loaded")
return getgenv().AutoFarmControl
