-- Auto Defuse Module (Fixed)
-- Automatically defuses bombs when in range
-- FIX: Improved bomb detection and circle visibility

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local CoreGui = game:GetService("CoreGui")

local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local AutoDefuseControl = {}
local defuseConnection = nil
local circleConnection = nil
local detectionCircles = {}

-- Initialize settings if not exists
if not getgenv().AutoDefuseSettings then
    getgenv().AutoDefuseSettings = {
        Enabled = false,
        Delay = 3000,
        ShowCircle = true,
        DetectionRadius = 30
    }
end

local function worldToScreen(position)
    local screenPos, onScreen = Camera:WorldToViewportPoint(position)
    return Vector2.new(screenPos.X, screenPos.Y), onScreen, screenPos.Z
end

local function createCircle()
    local circle = Drawing.new("Circle")
    circle.Thickness = 2
    circle.Color = Color3.fromRGB(255, 100, 100)
    circle.Filled = false
    circle.Transparency = 0.3
    circle.Visible = false
    return circle
end

-- Find all bombs in workspace
local function findBombs()
    local bombs = {}
    
    -- Search common bomb locations
    local searchLocations = {
        Workspace:FindFirstChild("Bombs"),
        Workspace:FindFirstChild("Map"),
        Workspace:FindFirstChild("Objects"),
        Workspace
    }
    
    -- Common bomb names to search for
    local bombNames = {"Bomb", "PlantedBomb", "C4", "Explosive", "TimeBomb", "BombPart"}
    
    for _, location in ipairs(searchLocations) do
        if location then
            for _, obj in pairs(location:GetDescendants()) do
                -- Check by name
                for _, bombName in ipairs(bombNames) do
                    if obj.Name:lower():find(bombName:lower()) then
                        if obj:IsA("BasePart") or obj:IsA("Model") then
                            table.insert(bombs, obj)
                            break
                        end
                    end
                end
                
                -- Check for ClickDetector (bombs usually have this)
                if obj:IsA("ClickDetector") then
                    local parent = obj.Parent
                    if parent and (parent:IsA("BasePart") or parent:IsA("Model")) then
                        -- Check if it looks like a bomb
                        local isLikelyBomb = false
                        for _, bombName in ipairs(bombNames) do
                            if parent.Name:lower():find(bombName:lower()) then
                                isLikelyBomb = true
                                break
                            end
                        end
                        -- Also add if parent has certain attributes
                        if parent:FindFirstChild("Fuse") or parent:FindFirstChild("Timer") or parent:FindFirstChild("Countdown") then
                            isLikelyBomb = true
                        end
                        if isLikelyBomb then
                            table.insert(bombs, parent)
                        end
                    end
                end
                
                -- Check for ProximityPrompt (some games use this)
                if obj:IsA("ProximityPrompt") then
                    local parent = obj.Parent
                    if parent then
                        for _, bombName in ipairs(bombNames) do
                            if parent.Name:lower():find(bombName:lower()) or 
                               obj.ActionText:lower():find("defuse") or
                               obj.ObjectText:lower():find("bomb") then
                                table.insert(bombs, parent)
                                break
                            end
                        end
                    end
                end
            end
        end
    end
    
    -- Remove duplicates
    local unique = {}
    local seen = {}
    for _, bomb in ipairs(bombs) do
        if not seen[bomb] then
            seen[bomb] = true
            table.insert(unique, bomb)
        end
    end
    
    return unique
end

local function getBombPosition(bomb)
    if bomb:IsA("BasePart") then
        return bomb.Position
    elseif bomb:IsA("Model") then
        if bomb.PrimaryPart then
            return bomb.PrimaryPart.Position
        end
        local part = bomb:FindFirstChildWhichIsA("BasePart")
        if part then
            return part.Position
        end
    end
    return nil
end

local function getDistanceToBomb(bomb)
    local character = LocalPlayer.Character
    if not character then return math.huge end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return math.huge end
    
    local bombPos = getBombPosition(bomb)
    if not bombPos then return math.huge end
    
    return (rootPart.Position - bombPos).Magnitude
end

local function tryDefuseBomb(bomb)
    -- Try ClickDetector
    local clickDetector = bomb:FindFirstChildWhichIsA("ClickDetector", true)
    if clickDetector then
        pcall(function()
            fireclickdetector(clickDetector)
        end)
        return true
    end
    
    -- Try ProximityPrompt
    local proximityPrompt = bomb:FindFirstChildWhichIsA("ProximityPrompt", true)
    if proximityPrompt then
        pcall(function()
            fireproximityprompt(proximityPrompt)
        end)
        return true
    end
    
    -- Try firing remote events
    local remotes = {"DefuseBomb", "Defuse", "DisarmBomb", "Disarm"}
    for _, remoteName in ipairs(remotes) do
        local remote = game:GetService("ReplicatedStorage"):FindFirstChild(remoteName, true)
        if remote and remote:IsA("RemoteEvent") then
            pcall(function()
                remote:FireServer(bomb)
            end)
            return true
        end
    end
    
    return false
end

local function updateCircles()
    -- Clear old circles
    for _, circle in pairs(detectionCircles) do
        pcall(function() circle:Remove() end)
    end
    detectionCircles = {}
    
    if not getgenv().AutoDefuseSettings.ShowCircle then return end
    if not getgenv().AutoDefuseSettings.Enabled then return end
    
    local bombs = findBombs()
    local radius = getgenv().AutoDefuseSettings.DetectionRadius
    
    for _, bomb in ipairs(bombs) do
        local bombPos = getBombPosition(bomb)
        if bombPos then
            local screenPos, onScreen, depth = worldToScreen(bombPos)
            
            if onScreen and depth > 0 then
                local circle = createCircle()
                
                -- Calculate screen radius based on distance
                local scaleFactor = 1000 / math.max(depth, 1)
                local screenRadius = math.clamp(radius * scaleFactor, 20, 200)
                
                circle.Position = screenPos
                circle.Radius = screenRadius
                circle.Visible = true
                
                -- Change color based on distance
                local distance = getDistanceToBomb(bomb)
                if distance <= radius then
                    circle.Color = Color3.fromRGB(0, 255, 0) -- Green when in range
                else
                    circle.Color = Color3.fromRGB(255, 100, 100) -- Red when out of range
                end
                
                table.insert(detectionCircles, circle)
            end
        end
    end
end

local function defuseLoop()
    local bombs = findBombs()
    local radius = getgenv().AutoDefuseSettings.DetectionRadius
    local delay = getgenv().AutoDefuseSettings.Delay / 1000 -- Convert to seconds
    
    for _, bomb in ipairs(bombs) do
        local distance = getDistanceToBomb(bomb)
        
        if distance <= radius then
            -- Wait for delay before defusing
            if delay > 0 then
                task.wait(delay)
            end
            
            -- Check if still in range and enabled
            if getgenv().AutoDefuseSettings.Enabled then
                local newDistance = getDistanceToBomb(bomb)
                if newDistance <= radius then
                    local success = tryDefuseBomb(bomb)
                    if success then
                        print("[AutoDefuse] Defused bomb at distance:", math.floor(newDistance))
                    end
                end
            end
        end
    end
end

function AutoDefuseControl.Start()
    getgenv().AutoDefuseSettings.Enabled = true
    
    -- Start defuse loop
    if not defuseConnection then
        defuseConnection = RunService.Heartbeat:Connect(function()
            if getgenv().AutoDefuseSettings.Enabled then
                pcall(defuseLoop)
            end
        end)
    end
    
    -- Start circle update loop
    if not circleConnection then
        circleConnection = RunService.RenderStepped:Connect(function()
            pcall(updateCircles)
        end)
    end
    
    print("[AutoDefuse] Started - Detection radius:", getgenv().AutoDefuseSettings.DetectionRadius)
end

function AutoDefuseControl.Stop()
    getgenv().AutoDefuseSettings.Enabled = false
    
    if defuseConnection then
        defuseConnection:Disconnect()
        defuseConnection = nil
    end
    
    if circleConnection then
        circleConnection:Disconnect()
        circleConnection = nil
    end
    
    -- Clean up circles
    for _, circle in pairs(detectionCircles) do
        pcall(function() circle:Remove() end)
    end
    detectionCircles = {}
    
    print("[AutoDefuse] Stopped")
end

-- Export control
getgenv().AutoDefuseControl = AutoDefuseControl

return AutoDefuseControl
