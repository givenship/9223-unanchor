-- Auto Defuse Script
-- Upload this to GitHub and use the raw link

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer

-- Get settings from global
local AutoDefuseSettings = getgenv().AutoDefuseSettings
if not AutoDefuseSettings then
    warn("AutoDefuseSettings not found - load Combat GUI first")
    return
end

-- Target animation IDs
local DEFUSE_ANIMATION_IDS = {
    "99918936475651",
    "115241304811827"
}

local detectionCircles = {} -- Store circles for each character

-- Check if animation ID matches defuse animations
local function isDefuseAnimation(numericId)
    if not numericId then return false end
    
    for _, targetId in pairs(DEFUSE_ANIMATION_IDS) do
        if numericId == targetId then
            return true
        end
    end
    return false
end

-- Get distance from local player
local function getDistance(character)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return math.huge
    end
    
    local targetHRP = character:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return math.huge end
    
    return (LocalPlayer.Character.HumanoidRootPart.Position - targetHRP.Position).Magnitude
end

-- Create outline circle using multiple parts
local function createDetectionCircle(character)
    if detectionCircles[character] then
        for _, part in pairs(detectionCircles[character]) do
            part:Destroy()
        end
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local radius = AutoDefuseSettings.DetectionRadius or 30
    local segments = 32 -- Number of segments for smooth circle
    local parts = {}
    
    for i = 1, segments do
        local angle1 = (i - 1) / segments * math.pi * 2
        local angle2 = i / segments * math.pi * 2
        
        local x1 = math.cos(angle1) * radius
        local z1 = math.sin(angle1) * radius
        local x2 = math.cos(angle2) * radius
        local z2 = math.sin(angle2) * radius
        
        -- Calculate segment position and size
        local midX = (x1 + x2) / 2
        local midZ = (z1 + z2) / 2
        local length = math.sqrt((x2 - x1)^2 + (z2 - z1)^2)
        
        -- Create segment part
        local segment = Instance.new("Part")
        segment.Name = "CircleSegment"
        segment.Size = Vector3.new(0.3, 0.3, length) -- Thin outline
        segment.Anchored = true
        segment.CanCollide = false
        segment.Material = Enum.Material.SmoothPlastic
        segment.Transparency = 0
        
        -- Position and rotate segment
        local segmentCFrame = hrp.CFrame * CFrame.new(midX, 0, midZ)
        local lookAt = CFrame.lookAt(Vector3.new(x1, 0, z1), Vector3.new(x2, 0, z2))
        segment.CFrame = segmentCFrame * CFrame.Angles(0, math.atan2(z2 - z1, x2 - x1), 0)
        
        segment.Parent = Workspace
        table.insert(parts, segment)
    end
    
    detectionCircles[character] = parts
    
    return parts
end

-- Remove detection circle
local function removeDetectionCircle(character)
    if detectionCircles[character] then
        for _, part in pairs(detectionCircles[character]) do
            part:Destroy()
        end
        detectionCircles[character] = nil
    end
end

-- Update circle colors and visibility based on distance
local function updateCircleColors()
    for character, parts in pairs(detectionCircles) do
        if character and character.Parent and parts then
            local distance = getDistance(character)
            local radius = AutoDefuseSettings.DetectionRadius or 30
            
            -- Determine color
            local color
            if distance <= radius then
                color = Color3.fromRGB(0, 255, 0) -- Green - in range
            else
                color = Color3.fromRGB(255, 0, 0) -- Red - out of range
            end
            
            -- Update all segments
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local segments = #parts
                
                for i, part in pairs(parts) do
                    if part and part.Parent then
                        part.Color = color
                        
                        -- Update position based on new radius
                        local angle1 = (i - 1) / segments * math.pi * 2
                        local angle2 = i / segments * math.pi * 2
                        
                        local x1 = math.cos(angle1) * radius
                        local z1 = math.sin(angle1) * radius
                        local x2 = math.cos(angle2) * radius
                        local z2 = math.sin(angle2) * radius
                        
                        local midX = (x1 + x2) / 2
                        local midZ = (z1 + z2) / 2
                        local length = math.sqrt((x2 - x1)^2 + (z2 - z1)^2)
                        
                        part.Size = Vector3.new(0.3, 0.3, length)
                        local segmentCFrame = hrp.CFrame * CFrame.new(midX, 0, midZ)
                        part.CFrame = segmentCFrame * CFrame.Angles(0, math.atan2(z2 - z1, x2 - x1), 0)
                        
                        -- Toggle visibility based on ShowCircle setting
                        part.Transparency = AutoDefuseSettings.ShowCircle and 0 or 1
                    end
                end
            end
        else
            -- Character removed, clean up
            if parts then
                for _, part in pairs(parts) do
                    if part then part:Destroy() end
                end
            end
            detectionCircles[character] = nil
        end
    end
end

-- Hook a character's animator
local function hookCharacter(character)
    if not AutoDefuseSettings.Enabled then return end
    
    local humanoid = character:WaitForChild("Humanoid", 5)
    if not humanoid then return end

    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then
        animator = Instance.new("Animator", humanoid)
    end

    animator.AnimationPlayed:Connect(function(track)
        if not AutoDefuseSettings.Enabled then return end
        
        local anim = track.Animation
        if not anim then return end

        local id = anim.AnimationId
        local numericId = id:match("%d+")
        if not numericId then return end

        print("Animation detected:", numericId, "from", character.Name)
        
        -- Check if it's a defuse animation
        if isDefuseAnimation(numericId) then
            -- Create circle for this character (always shown, even if ShowCircle is false)
            createDetectionCircle(character)
            
            -- Check distance
            local radius = AutoDefuseSettings.DetectionRadius or 30
            local distance = getDistance(character)
            
            if distance <= radius then
                local delayMs = AutoDefuseSettings.Delay or 3000
                
                print("DEFUSE ANIMATION DETECTED!")
                print("Character:", character.Name)
                print("Distance:", math.floor(distance), "studs")
                print("Waiting", delayMs, "milliseconds...")
                
                -- Wait for delay (convert ms to seconds)
                task.wait(delayMs / 1000)
                
                -- Send left click
                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
                task.wait(0.05)
                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
                
                print("Defused! (Clicked)")
                
                -- Remove circle after 2 seconds
                task.wait(2)
                removeDetectionCircle(character)
            else
                print("Too far away:", math.floor(distance), "studs (need â‰¤" .. radius .. ")")
                
                -- Remove circle after 2 seconds
                task.wait(2)
                removeDetectionCircle(character)
            end
        end
    end)
    
    print("Hooked character:", character.Name)
end

-- Start monitoring
local circleUpdateConnection = nil

local function startMonitoring()
    local characters = Workspace:FindFirstChild("Characters")
    
    if not characters then
        warn("Workspace.Characters not found! Looking in Workspace root instead...")
        characters = Workspace
    end
    
    -- Hook existing characters
    for _, character in ipairs(characters:GetChildren()) do
        if character:IsA("Model") then
            task.spawn(function()
                hookCharacter(character)
            end)
        end
    end
    
    -- Hook new characters
    characters.ChildAdded:Connect(function(character)
        if not AutoDefuseSettings.Enabled then return end
        
        task.wait(0.1) -- Let character fully load
        if character:IsA("Model") then
            task.spawn(function()
                hookCharacter(character)
            end)
        end
    end)
    
    -- Update circle colors every frame
    circleUpdateConnection = RunService.Heartbeat:Connect(function()
        if AutoDefuseSettings.Enabled then
            updateCircleColors()
        end
    end)
    
    print("Auto Defuse enabled - Event-based detection")
    print("Target IDs:", table.concat(DEFUSE_ANIMATION_IDS, ", "))
    print("Detection Radius:", AutoDefuseSettings.DetectionRadius or 30, "studs")
    print("Delay:", AutoDefuseSettings.Delay or 3000, "ms")
    print("Show Circle:", AutoDefuseSettings.ShowCircle and "Yes" or "No")
end

local function stopMonitoring()
    if circleUpdateConnection then
        circleUpdateConnection:Disconnect()
        circleUpdateConnection = nil
    end
    
    -- Remove all circles
    for character, parts in pairs(detectionCircles) do
        for _, part in pairs(parts) do
            part:Destroy()
        end
    end
    detectionCircles = {}
end

-- Export control functions
getgenv().AutoDefuseControl = {
    Start = function()
        AutoDefuseSettings.Enabled = true
        startMonitoring()
    end,
    Stop = function()
        AutoDefuseSettings.Enabled = false
        stopMonitoring()
        print("Auto Defuse disabled")
    end
}

print("Auto Defuse Script Loaded!")
return true
